<p>
    Кузнец дал своему ученику задание, приказав сделать набор колец.
    Ученик не был специалистом в этом деле и в результате некоторые кольца 
    (если честно, большинство) получились соединенными вместе. 
    Теперь он просит помощи в разделении колец и найти количество колец, 
    которое необходимо сломать, чтобы освободилось наибольшее число колец.
</p>

<p>
    Все кольца пронумерованы, и как было сказано соединены.
    Эта информация представлена как последовательность множеств.
    Каждое множество описывает соединенные кольца. Например: {1, 2} означает, что 1ое и 2е кольца соединены.
    Вы должны посчитать, сколько колец мы должны сломать, 
    чтобы получить максимальное число разделенных колец. 
    Каждое из колец пронумеровано в диапазоне от 1 до N, 
    где N является общим числом колец.
</p>

<p style="text-align: center;">
    <img class="for_info_only" title="example-rings" src="{{MEDIA}}example-rings.svg" alt="example-rings"/>
    <img class="for_editor_only" title="example-rings" src="{{MEDIA}}example-rings.svg" alt="example-rings"
         width="380px"/>
</p>

<p>
    На изображении выше вы можете видеть связи:
    ({1,2},{2,3},{3,4},{4,5},{4,6},{6,5}). 
    Оптимальным решением здесь разбить 3 кольца, 
    получив 3 целых и отдельных кольца. Таким образом ответ 3.
</p>
<p>
    <strong>Входные данные: </strong> Информация о связанных кольцах в виде кортежа множеств с целыми числами.
</p>

<p>
    <strong>Выходные данные: </strong> Количество разорванных колец, как целое.
</p>


<div class="for_info_only">
    <p>
        <strong>Примеры:</strong>
    </p>
    <textarea data-code="python">break_rings(({1, 2}, {2, 3}, {3, 4}, {4, 5}, {4, 6}, {6, 5})) == 3</textarea>
</div>

<p class="for_info_only">
    <strong>Как это используется: </strong>
    Эта модель специализируется на оптимизации чего-то с конкретными условиями.
    Используя основные понятия, можно создать модель для улучшения транспортной сетки.
</p>

<p>
    <strong>Предусловия:</strong>
    all(len(s) == 2 for s in rings)<br>
    sorted(reduce(set.union, rings)) == list(range(1, max(reduce(set.union, rings)) + 1))<br>
</p>
